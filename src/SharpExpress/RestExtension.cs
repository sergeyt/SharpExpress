using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Web.Routing;
using System.Web.Script.Serialization;

namespace SharpExpress
{
	internal interface INotifyModelChanged
	{
		event Action ModelChanged;
	}

	/// <summary>
	/// Use this attribute on property to ignore by <see cref="RestExtension"/>.
	/// </summary>
	[AttributeUsage(AttributeTargets.Property)]
	internal sealed class RestIgnoreAttribute : Attribute
	{
	}

	/// <summary>
	/// Use this attribute on method to bind POST handler generated by <see cref="RestExtension"/>.
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	internal sealed class RestAttribute : Attribute
	{
	}

	/// <summary>
	/// REST extension for <see cref="ExpressApplication"/>.
	/// </summary>
	internal static class RestExtension
	{
		// TODO detect recursive type hierarchies

		/// <summary>
		/// Builds REST handlers for given model function.
		/// </summary>
		/// <typeparam name="T">Model type.</typeparam>
		/// <param name="app"><see cref="ExpressApplication"/> to extend.</param>
		/// <param name="modelUrl">The model url.</param>
		/// <param name="getModel">The function which returns model instance.</param>
		public static ExpressApplication Rest<T>(this ExpressApplication app, string modelUrl, Func<RequestContext, T> getModel)
		{
			var i = 0;
			return RestImpl(app, modelUrl, typeof(T), () => i++, req => getModel(req), req => getModel(req));
		}

		private static object ModelPayload(RequestContext req, Func<RequestContext, object> instance)
		{
			return new {ViewModel = instance(req)};
		}

		private static ExpressApplication RestImpl(this ExpressApplication app,
			string url, Type type, Func<int> nextIndex,
			Func<RequestContext, object> getInstance,
			Func<RequestContext, object> getModel)
		{
			app.Get(url, req => req.Json(getInstance(req)));

			var props = type
				.GetProperties(BindingFlags.Public | BindingFlags.Instance)
				.Where(p => FilterProperty(p))
				.ToList();

			props.ForEach(prop =>
			{
				var propertyUrl = Combine(url, prop.Name);
				var getter = DynamicMethods.CompileGetter(type, prop);
				var setter = DynamicMethods.CompileSetter(type, prop);

				Func<RequestContext, object> propertyInstance = req =>
				{
					var instance = getInstance(req);
					return getter(instance);
				};

				app.Get(propertyUrl, req => req.Json(propertyInstance(req)));

				if (setter != null)
				{
					app.Update(propertyUrl, req =>
					{
						req.SetContext();

						var json = req.ParseJson();
						var hasChanges = ChangesDetector(req, getModel);
						var instance = getInstance(req);

						// TODO get default value from metadata
						var defval = GetDefaultValue(prop.PropertyType);
						var value = json.Get("value", defval, prop.PropertyType);

						setter(instance, value);

						req.Json(hasChanges() ? ModelPayload(req, getModel) : null);
					});
				}
				
				if (IsCollection(prop.PropertyType))
				{
					RestCollection(app, propertyUrl, prop.PropertyType, nextIndex, propertyInstance, getModel);
				}
				else if (IsObject(prop.PropertyType))
				{
					RestImpl(app, propertyUrl, prop.PropertyType, nextIndex, propertyInstance, getModel);
				}
			});

			var methods = type
				.GetMethods(BindingFlags.Public | BindingFlags.Instance)
				.Where(m => m.GetAttribute<RestAttribute>(true) != null)
				.ToList();

			methods.ForEach(method =>
			{
				var call = DynamicMethods.CompileMethod(type, method);

				app.Post(url, req =>
				{
					req.SetContext();

					var hasChanges = ChangesDetector(req, getModel);

					var args = req.ParseArgs(method.GetParameters());
					var collection = getInstance(req);
					var result = call(collection, args);

					req.Json(hasChanges() ? ModelPayload(req, getModel) : result);
				});
			});
			
			return app;
		}

		private static void RestCollection(this ExpressApplication app, string url, Type type, Func<int> nextIndex,
			Func<RequestContext, object> getInstance, Func<RequestContext, object> getModel)
		{
			var indexer = DynamicMethods.CompileIndexer(type);
			var indexName = "i" + nextIndex();
			var indexUrl = Combine(url, string.Format("{{{0}}}", indexName));

			Func<RequestContext, object> getItem = req =>
			{
				var index = req.Param<int>(indexName);
				var collection = getInstance(req);
				return indexer(collection, index);
			};

			if (indexer != null)
			{
				app.Get(indexUrl, req => req.Json(getItem(req)));
			}

			// TODO dispatch multiple Add methods
			var addMethod = type.GetMethod("Add");
			if (addMethod != null)
			{
				var add = DynamicMethods.CompileMethod(type, addMethod);
				app.Put(url, req =>
				{
					req.SetContext();

					var hasChanges = ChangesDetector(req, getModel);

					var args = req.ParseArgs(addMethod.GetParameters());
					var collection = getInstance(req);
					var result = add(collection, args);

					req.Json(hasChanges() ? ModelPayload(req, getModel) : result);
				});
			}

			var remove = DynamicMethods.CompileRemoveAt(type);
			if (remove != null)
			{
				app.Delete(indexUrl, req =>
				{
					req.SetContext();
					var hasChanges = ChangesDetector(req, getModel);
					var index = req.Param<int>(indexName);
					var collection = getInstance(req);
					var result = remove(collection, index);
					req.Json(hasChanges() ? ModelPayload(req, getModel) : result);
				});
			}

			var countProperty = type.GetProperty("Count", BindingFlags.Instance | BindingFlags.Public);
			if (countProperty != null && countProperty.GetIndexParameters().Length == 0)
			{
				var count = DynamicMethods.CompileGetter(type, countProperty);

				app.Get(Combine(url, "Count"), req =>
				{
					var collection = getInstance(req);
					req.Json(count(collection));
				});
			}

			var itemType = GetItemType(type);
			if (IsObject(itemType))
			{
				RestImpl(app, indexUrl, itemType, nextIndex, getItem, getModel);
			}
		}

		private static Func<bool> ChangesDetector(RequestContext req, Func<RequestContext, object> getModel)
		{
			var root = getModel(req);

			var model = root as INotifyModelChanged;
			if (model == null)
			{
				return () => false;
			}

			bool changed = false;
			Action handler = () => changed = true;
			model.ModelChanged += handler;

			return () =>
			{
				model.ModelChanged -= handler;
				return changed;
			};
		}

		#region Helpers

		private static bool FilterProperty(PropertyInfo p)
		{
			// ignore indexers
			if (p.GetIndexParameters().Length > 0)
				return false;

			if (p.GetAttribute<RestIgnoreAttribute>(true) != null)
				return false;

			if (p.GetAttribute<ScriptIgnoreAttribute>(true) != null)
				return false;

			return true;
		}

		private static string Combine(string prefix, string suffix)
		{
			if (string.IsNullOrEmpty(prefix)) return suffix;
			return prefix.EndsWith("/") ? prefix + suffix : prefix + "/" + suffix;
		}

		private static object GetDefaultValue(Type type)
		{
			return type == typeof(string) ? null : Activator.CreateInstance(type);
		}

		private static bool IsObject(Type type)
		{
			if (type == null) return false;

			if (type.IsValueType)
			{
				// TODO support structures
				return false;
			}

			if (type == typeof(string))
			{
				return false;
			}

			return true;
		}

		private static bool IsCollection(Type type)
		{
			return type != null && type != typeof(string) && typeof(IEnumerable).IsAssignableFrom(type);
		}

		private static Type FindEnumerableInterface(Type type)
		{
			if (type == null || type == typeof(string))
				return null;

			if (type.IsArray)
				return typeof(IEnumerable<>).MakeGenericType(type.GetElementType());

			if (type.IsGenericType)
			{
				var ienum = type.GetGenericArguments()
								.Select(x => typeof(IEnumerable<>).MakeGenericType(x))
								.FirstOrDefault(x => x.IsAssignableFrom(type));
				if (ienum != null)
				{
					return ienum;
				}
			}

			var ifaces = type.GetInterfaces();
			if (ifaces.Length > 0)
			{
				var ienum = ifaces.Select(x => FindEnumerableInterface(x)).FirstOrDefault(x => x != null);
				if (ienum != null)
				{
					return ienum;
				}
			}

			if (type.BaseType != null && type.BaseType != typeof(object))
			{
				return FindEnumerableInterface(type.BaseType);
			}

			return null;
		}

		private static Type GetItemType(Type type)
		{
			if (type.IsArray) return type.GetElementType();
			var ienum = FindEnumerableInterface(type);
			return ienum != null ? ienum.GetGenericArguments()[0] : null;
		}

		#endregion
	}
}
